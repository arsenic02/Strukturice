//1.
void LList::GroupElements()
{
	LListNode* ptr1 = head;
	LListNode* ptr2 = ptr1->next;
	LListNode* savePtr2;
	LListNode* savePtr1Next;
	LListNode* prevPtr2;
	while (ptr1 != nullptr )
	{
		while (ptr2 != nullptr && ptr1->info != (ptr2->info))//nema potrebe za prelancavanjem ako su u listi vec isti elementi jedni pored drugih
		{
			ptr2 = ptr2->next;
		}
		prevPtr2 = ptr1;
		while (prevPtr2->next != ptr2)
		{
			prevPtr2 = prevPtr2->next;
		}
		if (ptr2!=nullptr && ptr1->info == ptr2->info)//proverava se razlog izlaska iz petlje
		{
			savePtr2 = ptr2;
			prevPtr2->next = savePtr2->next;
			savePtr1Next = ptr1->next;//cuva se ptr1 next
			ptr1->next = ptr2;//ptr1 pokazuje na svoj duplikat
			ptr1->next->next = savePtr1Next;//duplikat pokazuje na sledeci cvor koji je bio sledbenik ptr1
			
		}
		ptr1 = ptr1->next;
		if(ptr1!=nullptr)
			ptr2 = ptr1->next;
	}
}
//4.
int GraphAsListsInt::getMaxConnectionsDisjointSubgraph()
{
	LinkedNodeInt* temp = start;
	setStatusForAllNodes(1);
	LinkedNodeInt* nextNode = temp;
	int maxCount = 0, curCount;
	QueueAsArrayLinkedNodeInt qju(nodeNum);
	while (temp != 0)
	{
		qju.enqueue(temp);
		temp->status = 1;
		curCount = 0; // Resetovanje brojaca trenutnog broja potega
		while (!qju.isEmpty())
		{
			temp = qju.dequeue();
			temp->status = 2;
			LinkedEdgeInt* edge = temp->adj;
			while (edge != nullptr)
			{
				if (edge->dest->status == 0)
				{
					qju.enqueue(edge->dest);
					edge->dest->status = 1;
				}
				if (edge->dest->status != 2)//kad je status=2, cvor je vec obradjen, da sse spreci dupliranje
					curCount++;
				edge = edge->link;
			}
		}
		if (curCount > maxCount)
			maxCount = curCount;
		while (nextNode != 0 && nextNode->status != 0)
			nextNode = nextNode->next;
		temp = nextNode;
	}
	return maxCount;
}
