//1.
void LList::GroupElements()
{
	LListNode* ptr1 = head;
	LListNode* ptr2 = ptr1->next;
	LListNode* savePtr2;
	LListNode* savePtr1Next;
	LListNode* prevPtr2;
	while (ptr1 != nullptr )
	{
		while (ptr2 != nullptr && ptr1->info != (ptr2->info))//nema potrebe za prelancavanjem ako su u listi vec isti elementi jedni pored drugih
		{
			ptr2 = ptr2->next;
		}
		prevPtr2 = ptr1;
		while (prevPtr2->next != ptr2)
		{
			prevPtr2 = prevPtr2->next;
		}
		if (ptr2!=nullptr && ptr1->info == ptr2->info)//proverava se razlog izlaska iz petlje
		{
			savePtr2 = ptr2;
			prevPtr2->next = savePtr2->next;
			savePtr1Next = ptr1->next;//cuva se ptr1 next
			ptr1->next = ptr2;//ptr1 pokazuje na svoj duplikat
			ptr1->next->next = savePtr1Next;//duplikat pokazuje na sledeci cvor koji je bio sledbenik ptr1
			
		}
		ptr1 = ptr1->next;
		if(ptr1!=nullptr)
			ptr2 = ptr1->next;
	}
}
//2.
unsigned int HashTable::h(char* key)
{
	return g(f(key));
}

unsigned int HashTable::f(char* key)
{
	//TODO:Implementirati funkciju koja prevodi char u unsigned int
	unsigned int res = 0;
	for (int i = 11; i > 6; i--)
		res = res << 7 ^ key[i];
	return res;
}

unsigned int HashTable::g(unsigned int key)
{
	//TODO:Implementirati funkciju koja prevodi unsigned int u [0...M-1]
	const unsigned int a = 2654435769;
	unsigned long long ak = a * key;
	return ak>>(32-(int)log2(getLength()));
}
void withdraw(const char* key) {
    uint index = h(key); 

    if (table[index].status != 2)
        return;

    uint prev = -1; // Indeks prethodnog elementa inicijalno postavljen na -1

    // Pretraga dok se ne nađe ključ ili dođe do kraja niza
    while (index != -1 and index != 0 and strcmp(table[index].getKey(), key) != 0) {
        prev = index;
        index = table[index].next; // Prelazak na sledeći element u lancu
    }

    // Brisanje iz tablice
    if (prev == -1 and table[index].next == -1) {
        table[index].status = 1; // Promena statusa na slobodno (1)
    }
    else if (prev == -1 and table[index].next != -1) {
        prev = index;
        index = table[index].next; // Prelazak na sledeći element
        table[prev] = table[index]; // Kopiranje sledećeg elementa preko trenutnog
        table[index].next = lrmp; // Postavljanje sledećeg elementa kao poslednji oslobođeni
        table[index].status = 1; // Promena statusa na slobodno (1)
        lrmp = index; // Ažuriranje poslednjeg oslobođenog
    }
    else {
        table[prev].next = table[index].next; // Povezivanje prethodnog elementa sa sledećim
        table[index].status = 1; // Promena statusa na slobodno (1)
        table[index].next = lrmp; // Postavljanje sledećeg elementa kao poslednji oslobođeni
        lrmp = index; // Ažuriranje poslednjeg oslobođenog
    }

    count -= 1; // Smanjenje broja elemenata u tabeli za 1
}

//4.
int GraphAsListsInt::getMaxConnectionsDisjointSubgraph()
{
	LinkedNodeInt* temp = start;
	setStatusForAllNodes(1);
	LinkedNodeInt* nextNode = temp;
	int maxCount = 0, curCount;
	QueueAsArrayLinkedNodeInt qju(nodeNum);
	while (temp != 0)
	{
		qju.enqueue(temp);
		temp->status = 1;
		curCount = 0; // Resetovanje brojaca trenutnog broja potega
		while (!qju.isEmpty())
		{
			temp = qju.dequeue();
			temp->status = 2;
			LinkedEdgeInt* edge = temp->adj;
			while (edge != nullptr)
			{
				if (edge->dest->status == 0)
				{
					qju.enqueue(edge->dest);
					edge->dest->status = 1;
				}
				if (edge->dest->status != 2)//kad je status=2, cvor je vec obradjen, da sse spreci dupliranje
					curCount++;
				edge = edge->link;
			}
		}
		if (curCount > maxCount)
			maxCount = curCount;
		while (nextNode != 0 && nextNode->status != 0)
			nextNode = nextNode->next;
		temp = nextNode;
	}
	return maxCount;
}
