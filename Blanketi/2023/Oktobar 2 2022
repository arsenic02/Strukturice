//1. zadatak
void LList::MoveMinToHead(LListNode** start)
{
	LListNode* ptr1=head;
	LListNode* ptr2 = ptr1->next;
	LListNode* min = head;
	LListNode* pom;
	LListNode* pSaveHead=head;//cuva head prilikom prelancavanja
	LListNode* pSaveMin;
	LListNode* prevMin=head;
	while (ptr1->next != nullptr && ptr2 != nullptr)
	{
		if ((ptr1->info) < (ptr2->info))
			min = ptr1;
		else
			min = ptr2;

		if (min != head)//ako je min prvi cvor nema prelancavanja
		{
			while (prevMin->next != min)
			{
				prevMin = prevMin->next;
			}
		}
		ptr1 = ptr1->next;
		ptr2 = ptr2->next;
	}
	pSaveMin = min->next;
	min->next = head->next;//prelancava se tako da min pokazuje na 2. cvor  u listi
	head = min;//min je sada na pocetku liste
	prevMin->next = pSaveHead;//stari  head se zamenjuje sa min
	pSaveHead->next = pSaveMin;//stari  head se lancava sa sledecim cvorovima
}
