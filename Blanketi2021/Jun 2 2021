//4.
int reachableInNHoops(GraphNode* a, int n) {
//bolje red/stek za ovakve zadatke, dijkstra samo kad se trazi najkraci put!!!
    // Postavljanje privremenog pokazivača za prolazak kroz čvorove grafa
    GraphNode* temp = start;

    // Postavljanje statusa i udaljenosti svakog čvora na početne vrednosti
    while (temp != 0) {
        temp->status = 1;    
        temp->distance = 0;   // Postavljanje udaljenosti čvora na 0
        temp = temp->next;   
    }

    int count = 0;           // Inicijalizacija brojača čvorova dostižnih tačno za n koraka
    temp = a;                

    queue<GraphNode*> qju;   
    qju.push(temp);          
    temp->status = 2;        


    while (not qju.empty()) {
        temp = qju.front();   
        qju.pop();            
        temp->status = 3;     

       
        GraphEdge* edge = temp->adj;
        while (edge != 0) {
            if (edge->dest->status == 1) {
                edge->dest->status = 2;  
                qju.push(edge->dest);    // Stavljanje odredišnog čvora u red za obradu
            }

            // Provera udaljenosti i obavljanje potrebne obrade
            if (edge->dest->distance != n) {
                bool modifiable = edge->dest->distance != 0;  // Provera da li je udaljenost prethodno bila razlicita od 0 pre
/*nego sto se postavila nova udaljenost,Ako je udaljenost bila različita od 0, to znači da je već bila postavljena u prethodnom
prolazu kroz graf. U tom slučaju, nakon što se postavi nova udaljenost, korak se nazad smanjuje (oduzima 1) kako bi se tačna 
udaljenost čuvala samo za prvi put kad je čvor dostignut tačno nakon n koraka. Ovo osigurava da se ne gubi tačna udaljenost 
čvora u slučaju da je već obrađen u prethodnim koracima.*/
                
                edge->dest->distance = temp->distance + 1;    // Postavljanje udaljenosti odredišnog čvora

                if (edge->dest->distance == n && edge->dest->status != 4) {
                    count += 1;                  // Povećanje broja čvorova dostižnih tačno za n koraka
                    cout << edge->dest->key << endl;  // Ispis ključa čvora
                    edge->dest->status = 4;      // Postavljanje statusa čvora na 4 (obradjen)
                    if (modifiable)
                        edge->dest->distance -= 1;  
                } else if (edge->dest->distance == n && edge->dest->status == 4) {
                    edge->dest->distance -= 1;  // Smanjenje udaljenosti ako je čvor već obradjen
                }
            }

            edge = edge->next;  
        }
    }

    return count;  
}
