//3. 
int BSTreeInt::countSL(BSTNodeInt* root)
{
	if(root == nullptr)
		countKeys(root);
	int countLeft = countKeys(root->left);
	int countRight = countKeys(root->right);
	int count = 0;
	if (countLeft > countRight)
		count++;
	return count + countSL(root->left) + countSL(root->right);
}
int BSTreeInt::countKeys(BSTNodeInt* root)
{
	if (root == 0)
		return 0;
	return root->key + countKeys(root->left) + countKeys(root->right);
}
//4.
int reachableInNHoops(GraphNode* a, int n) {
    // Postavljanje privremenog pokazivača za prolazak kroz čvorove grafa
    GraphNode* temp = start;

    // Postavljanje statusa i udaljenosti svakog čvora na početne vrednosti
    while (temp != 0) {
        temp->status = 1;    
        temp->distance = 0;   // Postavljanje udaljenosti čvora na 0
        temp = temp->next;   
    }

    int count = 0;           // Inicijalizacija brojača čvorova dostižnih tačno za n koraka
    temp = a;                

    queue<GraphNode*> qju;   
    qju.push(temp);          
    temp->status = 2;        


    while (not qju.empty()) {
        temp = qju.front();   
        qju.pop();            
        temp->status = 3;     

       
        GraphEdge* edge = temp->adj;
        while (edge != 0) {
            if (edge->dest->status == 1) {
                edge->dest->status = 2;  
                qju.push(edge->dest);    // Stavljanje odredišnog čvora u red za obradu
            }

            // Provera udaljenosti i obavljanje potrebne obrade
            if (edge->dest->distance != n) {
                bool modifiable = edge->dest->distance != 0;  // Provera da li je udaljenost promenljiva
                edge->dest->distance = temp->distance + 1;    // Postavljanje udaljenosti odredišnog čvora

                if (edge->dest->distance == n && edge->dest->status != 4) {
                    count += 1;                  // Povećanje broja čvorova dostižnih tačno za n koraka
                    cout << edge->dest->key << endl;  // Ispis ključa čvora
                    edge->dest->status = 4;      // Postavljanje statusa čvora na 4 (obradjen)
                    if (modifiable)
                        edge->dest->distance -= 1;  // Smanjenje udaljenosti ako je bila promenljiva
                } else if (edge->dest->distance == n && edge->dest->status == 4) {
                    edge->dest->distance -= 1;  // Smanjenje udaljenosti ako je čvor već obradjen
                }
            }

            edge = edge->next;  
        }
    }

    return count;  
}

//4. ovo ide u drugi rok 
void breadthVariant(LinkedNodeInt* node1, int maxH) {
    LinkedNodeInt* temp = start;//zasto  ovde greska
    while (temp != 0) {
        temp->status = 1;
        temp->prev = 0;   // Postavi prethodnika čvora na nulu (0)
        temp = temp->next;
    }
    temp = node1; // Postavi temp na početni čvor
    QueueAsArrayLinkedNodeInt qju (nodeNum);//zasto ovde greska
    qju.enqueue(temp);
    temp->status = 2;
    while (!qju.isEmpty()) {
        // Uzmi čvor sa početka reda
        temp = qju.dequeue();
        temp->status = 3;
        LinkedEdgeInt* edge = temp->adj; // Pokazivač na prvu granu koja izlazi iz čvora
        while (edge != 0) {
            if (edge->dest->status == 1 and edge->weight < maxH) { // Ako je čvor neposećen i težina grane je manja od maxH
                qju.enqueue(edge->dest); // Dodaj odredišni čvor u red za dalje istraživanje
                edge->dest->status = 2;
                edge->dest->prev = temp; // Postavi prethodnika odredišnog čvora na trenutni čvor
            }
            edge = edge->link;
        }
    }
}

// Funkcija za pronalaženje najboljeg puta između tri čvora u grafu
LinkedNodeInt* boljiPut(LinkedNodeInt* nodeA, LinkedNodeInt* nodeB, LinkedNodeInt* nodeC, int maxH, int* brPresedanja) {
    breadthVariant(nodeA, maxH); // Primeni pretragu u širinu sa početnim čvorom nodeA
    int presedanjaB = 0, presedanjaC = 0; // Brojači za presedanja do čvorova nodeB i nodeC
    bool existsPathToB = false, existsPathToC = false; // Da li postoji put do čvorova nodeB i nodeC
    LinkedNodeInt* temp = nodeB; // Postavi temp na nodeB
    while (temp != 0 and temp != nodeA) { // Računaj presedanja do nodeB
        presedanjaB += 1;
        temp = temp->prev;
    }
    if (temp == nodeA)
        existsPathToB = true; // Ako je temp stigao do nodeA, postoji put do nodeB
    temp = nodeC; // Postavi temp na nodeC
    while (temp != 0 and temp != nodeA) { // Računaj presedanja do nodeC
        presedanjaC += 1;
        temp = temp->prev;
    }
    if (temp == nodeA)
        existsPathToC = true; // Ako je temp stigao do nodeA, postoji put do nodeC
    if (existsPathToB and existsPathToC) { // Ako postoje putevi do oba nodeB i nodeC
        if (presedanjaB < presedanjaC) { // Izaberi put sa manje presedanja
            *brPresedanja = presedanjaB;
            return nodeB;
        }
        else {
            *brPresedanja = presedanjaC;
            return nodeC;
        }
    }
    else if (existsPathToB) { // Ako postoji put do nodeB
        *brPresedanja = presedanjaB;
        return nodeB;
    }
    else if (existsPathToC) { // Ako postoji put do nodeC
        *brPresedanja = presedanjaC;
        return nodeC;
    }
    else { // Ako ne postoji put do nodeB ni nodeC
        *brPresedanja = -1; // Postavi broj presedanja na -1
        return nodeA; // Vrati nodeA
    }
}
