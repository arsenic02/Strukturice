///////    1.
LList* LList::SplitOrMove()
{
	LList* novaLista = new LList();
	LListNode* tmp = head;
	LListNode* tmp1;
	while (tmp != nullptr && tmp->next!=nullptr )
	{
		tmp1 = tmp->next;
		while ( tmp1!=nullptr && tmp1->next!=nullptr)
		{
			if ((tmp->info) == (tmp1->info))
				break;
			tmp1 = tmp1->next;
		}
		if ((tmp->info) == (tmp1->info) && tmp1!=nullptr)
		{
			novaLista->addToHead(tmp1->info);
		}
		else
			if(!novaLista->isInList(tmp->info))
			novaLista->addToHead(tmp->info);
		tmp = tmp->next;
	}
	return novaLista;
}
//////////////////////////////////////////////////////////////////////////////
//3. zadatak
int brojCvorova(int keyMin, double valueMin) {
	return brojCvorova(root, keyMin, valueMin, false);
}// ancestor - predak
int brojCvorova(BSTNode* root, int keyMin, double valueMin, bool ancestorExists) {
	if (root == 0)
		return 0;
	int count = 0;
	if (root->key > keyMin and ancestorExists)//Ako oba uslova su ispunjena, to znači da je trenutni čvor unuk nekog prethodnog čvora koji takođe zadovoljava uslov ključa, pa se u ovom slučaju uvećava brojač za 1 
		count += 1 + brojCvorova(root->left, keyMin, valueMin, true) + brojCvorova(root->right, keyMin, valueMin, true);
	//ovaj drugi  uslov mi nelogicno za not ancestorExists???, dodavanje 1???
	else if (not ancestorExists and root->value > valueMin)// da li cvor nema prethodnika u smislu da nema prethodnike koji zadovoljavaju uslov value > valueMin
		count += brojCvorova(root->left, keyMin, valueMin, true) + brojCvorova(root->right, keyMin, valueMin, true);
	else
		count += brojCvorova(root->left, keyMin, valueMin, false) + brojCvorova(root->right, keyMin, valueMin, false);
	return count;
}
//4.
void GraphAsListsInt::bfs(LinkedNodeInt* node)
{
	LinkedNodeInt* temp = node;
	QueueAsArrayLinkedNodeInt qju(nodeNum);
	qju.enqueue(temp);
	temp->status = 2;


	while (!qju.isEmpty()) 
	{
		temp=qju.dequeue();
		temp->status = 3;
		LinkedEdgeInt* edge = temp->adj;
		while (edge != 0) {

			if (edge->dest->status == 1) {
				qju.enqueue(edge->dest);
				edge->dest->status = 2;
				edge->dest->prev = temp;//dodato  ovo u odnosu na standardnu bfs
			}
			edge = edge->link;
		}
	}
}
int GraphAsListsInt::BridgeCount(int a, int b)
{
	LinkedNodeInt* temp = start;
	LinkedNodeInt* A = 0, * B = 0;

	//A = findNode(a); ne radi lepo sa ovim
	//B = findNode(b); ne radi lepo sa ovim
	while (temp != 0) {
		temp->status = 1;  // Postavljamo status čvora na 1 (označava da nije posećen).
		temp->prev = 0;

		if (temp->node == a)
			A = temp;

		if (temp->node == b)
			B = temp;

		temp = temp->next;  // Pomeramo se na sledeći čvor.
	}

	// Ako nismo pronašli oba čvora, vraćamo -1.
	if (A == 0 or B == 0)
		return -1;

	bfs(A);
	int count = 0;
	temp = B;

	// Računamo broj mostova tako što pratimo prethodne čvorove unazad od čvora 'B' do čvora 'A'.
	while (temp != 0 and temp != A) {
		count += 1;         // Povećavamo brojač.
		temp = temp->prev;  // Prelazimo na prethodni čvor.
	}

	// Ako smo stigli do čvora 'A', vraćamo broj mostova, inače vraćamo -1.
	return (temp == A) ? count : -1;
}
////////////////////Ako je tezinski graf dijkstra
//priority queue je naparavljena klasa sa metodama
int GraphAsListsInt:: bridgeCount(int a, int b) {//ova metoda trazi  ptr1 i ptr2
	if (start == 0)
		return -1;

	LinkedNodeInt* temp = start;
	LinkedNodeInt* pFirst = 0, * pLast = 0;

	// Inicijalizacija čvorova grafa i pronalaženje čvorova 'pFirst' i 'pLast'.
	while (temp != 0) {
		temp->status = 1; // Postavljamo status čvora na 1 (nije posećen).
		temp->distance = INT_MAX; // Postavljamo udaljenost čvora na maksimalnu vrednost.
		temp->prev = 0;

		if (temp->node == a)
			pFirst = temp; // Čuvamo čvor 'pFirst' ako ključ odgovara 'a'.

		if (temp->node == b)
			pLast = temp; // Čuvamo čvor 'pLast' ako ključ odgovara 'b'.

		temp = temp->next; // Pomeramo se na sledeći čvor.
	}

	if (pFirst == 0 or pLast == 0)
		return -1;

	return bridgeCount(pFirst, pLast);
}

// Ova funkcija računa broj mostova između dva čvora 'first' i 'last' koristeći BFS sa prioritetnim redom.
int GraphAsListsInt::bridgeCount(LinkedNodeInt* first, LinkedNodeInt* last) {
	LinkedNodeInt* temp = first;
	PriorityQueue pqju(nodeNum);
	//fja 90% ista kao sa vezbi za dijkstru
	pqju.insert(temp,1);//nisam siguran za drugi parametar sta da stavim, to je prioritet
	temp->status = 2; // Postavljamo status čvora na 2 (u redu za posetu).
	temp->distance = 0; // Postavljamo udaljenost prvog čvora na 0.

	// Glavna petlja BFS algoritma sa prioritetnim redom.
	while (not pqju.isEmpty()) {
		temp = pqju.removeFirst(); // Uzimamo prvi čvor iz reda.

		temp->status = 3; //posećen

		LinkedEdgeInt* edge = temp->adj;
		while (edge != 0)
		{
			if (edge->dest->status == 1)
			{ // Ako je susedni čvor ne posećen.
				edge->dest->status = 2; // Postavljamo status čvora na 2.
				edge->dest->prev = temp; // Postavljamo prethodni čvor.

				// Računamo udaljenost i ubacujemo čvor u prioritetni red.
				edge->dest->distance = temp->distance + edge->weight;//racunanje udaljenosti
				pqju.insert(edge->dest,1);
			}
			else if (edge->dest->status == 2)
			{ // Ako je susedni čvor već u redu za posetu.
				if (edge->dest->distance > temp->distance + edge->weight)
				{// Ako je udaljenost preko trenutnog puta manja, ažuriramo udaljenost i prethodnika.
					pqju.update(edge->dest, temp->distance + edge->weight);//azuriranje udaljenosti u redu
					edge->dest->prev = temp;
				}
			}
			edge = edge->link; 
		}
	}

	// Računamo broj mostova prateći put unazad od 'last' do 'first'.
	int count = 1;
	temp = last->prev;
	while (temp != 0 and temp != first) {
		count += 1;
		temp = temp->prev;
	}

	// Vraćamo rezultat, ako smo stigli do 'first', inače -1.
	return (temp == first) ? count : -1;
}
