///////    1.
LList* LList::SplitOrMove()
{
	LList* novaLista = new LList();
	LListNode* tmp = head;
	LListNode* tmp1;
	while (tmp != nullptr && tmp->next!=nullptr )
	{
		tmp1 = tmp->next;
		while ( tmp1!=nullptr && tmp1->next!=nullptr)
		{
			if ((tmp->info) == (tmp1->info))
				break;
			tmp1 = tmp1->next;
		}
		if ((tmp->info) == (tmp1->info) && tmp1!=nullptr)
		{
			novaLista->addToHead(tmp1->info);
		}
		else
			if(!novaLista->isInList(tmp->info))
			novaLista->addToHead(tmp->info);
		tmp = tmp->next;
	}
	return novaLista;
}
//////////////////////////////////////////////////////////////////////////////
//3. zadatak
int brojCvorova(int keyMin, double valueMin) {
	return brojCvorova(root, keyMin, valueMin, false);
}// ancestor - predak
int brojCvorova(BSTNode* root, int keyMin, double valueMin, bool ancestorExists) {
	if (root == 0)
		return 0;
	int count = 0;
	if (root->key > keyMin and ancestorExists)//Ako oba uslova su ispunjena, to znači da je trenutni čvor unuk nekog prethodnog čvora koji takođe zadovoljava uslov ključa, pa se u ovom slučaju uvećava brojač za 1 
		count += 1 + brojCvorova(root->left, keyMin, valueMin, true) + brojCvorova(root->right, keyMin, valueMin, true);
	//ovaj drugi  uslov mi nelogicno za not ancestorExists???, dodavanje 1???
	else if (not ancestorExists and root->value > valueMin)// da li cvor nema prethodnika u smislu da nema prethodnike koji zadovoljavaju uslov value > valueMin
		count += brojCvorova(root->left, keyMin, valueMin, true) + brojCvorova(root->right, keyMin, valueMin, true);
	else
		count += brojCvorova(root->left, keyMin, valueMin, false) + brojCvorova(root->right, keyMin, valueMin, false);
	return count;
}
